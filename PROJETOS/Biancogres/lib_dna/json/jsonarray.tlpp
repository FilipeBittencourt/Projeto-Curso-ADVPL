/*----------------------------------------------------------------------
JSON for AdvPL

Copyright (C) 2013  Arthur Helfstein Fragoso
Copyright (C) 2020  Marinaldo de Jesus

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation,either version 3 of the License,or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the
GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not,see <http://www.gnu.org/licenses/>.

This program includes the function JSONMinify that is a ported version
of JSONLint by Chris Dary. Here is his original license: (MIT License)

Copyright (c) 2011 Chris Dary.

Permission to use,copy,modify,and/or distribute this software for any
purpose with or without fee is hereby granted,provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL,DIRECT,INDIRECT,OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE,DATA OR PROFITS,WHETHER IN AN
ACTION OF CONTRACT,NEGLIGENCE OR OTHER TORTIOUS ACTION,ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

----------------------------------------------------------------------

How to use this program:

1 - Add the files JSONArray.tlpp and jsonhash.tlpp to your project.

2 - Compile JSONArray.tlpp and jsonhash.tlpp.

3 - Include the header files to any project you want to use it:

  #include "jsonarray.ch"
  #include "jsonhash.ch"

4 - See the functions documentation,it's very easy to use it. ;)

----------------------------------------------------------------------*/
#include "totvs.ch"
#include "parmtype.ch"
#include "jsonarray.ch"
#include "set_default.ch"

#define XML_NLS_ATTRIBUTE_ND "@__NAMESPACE_ND__@@__ATTRIBUTE_ND__@@__ATTRIBUTE_ND__@@__ATTRIBUTE_ND__@@__ATTRIBUTE_ND__@@__ATTRIBUTE_ND__@"
#define XML_NLS_ATTRIBUTE_NS "@__NAMESPACE_NS__@@__ATTRIBUTE_NS__@@__ATTRIBUTE_NS__@@__ATTRIBUTE_NS__@@__ATTRIBUTE_NS__@@__ATTRIBUTE_NS__@"

/*namespace dna.JSONArray*/

// ASCII Characteres
static CHR_CRLF     as character
static nCHR_CRLF    as numeric

static CHR_BS       as character
static CHR_HT       as character
static CHR_LF       as character
static CHR_VT       as character
static CHR_FF       as character
static CHR_CR       as character

static CHR_lt       as character
static CHR_gt       as character
static CHR_Amp      as character
static CHR_Apos     as character
static CHR_Quot     as character
static CHR_PTeV     as character

function u_JSONArray(lSection as logical,lHashAsFile as logical) as object
    return(JSONArray():New(lSection,lHashAsFile))

    class JSONArray from JSONhash

    data cClassName         as character

    public data lPrettify   as logical
    public data nPrettify   as logical
    public data nTimeStamp  as logical

    public data lUTF8       as logical
    public data lNoAccent   as logical
    public data lTrimSpace  as logical
    
    public method New(lSection,lHashAsFile) as object /*/\constructor/\*/

    public method ClassName() as character

    public method ToJSON(uAnyVar) as character
    public method ToJSONFile(uAnyVar,cJSONFile) as logical

    public method ToXML(cRoot,cAttrSuffix,lArrayToList) as character
    
    public method ToHTML(lXML,cAttrSuffix) as character
    public method ToXHTML() as character

    public method FromINI(cINIStr,cIgnoreToken) as character
    public method FromXML(cXMLstr,cAttrSuffix,cURL,cEncoding,nOptions,lNameSpaces) as character
    public method FromJSON(cJSONstr) as object
    public method FromHashMap(oJSONHashMap) as object
    
    public method JSONParser(cJSONstr,lSetFromObject) as object
    public method JSONParserFile(cFileName,lSetFromObject) as object

    public method EscpJSONStr(cJSONStr) as character

    public method JSONMinify(cJSONstr) as character
    public method JSONPrettify(cJSONstr,nPrettify) as character

    public method ReadINIFile(cIniFile,cIgnoreToken) as character
    public method ReadXMLFile(cFileName,cAttrSuffix,cURL,cEncoding,nOptions,lNameSpaces) as character
    public method ReadJSONFile(cFileName,lStripComments) as object

    end class

method New(lSection,lHashAsFile) class JSONArray

    DEFAULT lSection:=.F.
    paramtype lSection as logical optional
    DEFAULT lHashAsFile:=.F.
    paramtype lHashAsFile as logical optional

    _Super:New(lSection,lHashAsFile)
    self:ClassName()

    DEFAULT self:lUTF8:=.T.
    DEFAULT self:lNoAccent:=.T.
    DEFAULT self:lTrimSpace:=.T.

    DEFAULT self:lPrettify:=.F.
    DEFAULT self:nPrettify:=4
    DEFAULT self:nTimeStamp:=0

    DEFAULT CHR_CRLF:=(chr(13)+chr(10))
    DEFAULT nCHR_CRLF:=len(CHR_CRLF)

    DEFAULT CHR_BS:=chr(8)
    DEFAULT CHR_HT:=chr(9)
    DEFAULT CHR_LF:=chr(10)
    DEFAULT CHR_VT:=chr(11)
    DEFAULT CHR_FF:=chr(12)
    DEFAULT CHR_CR:=chr(13)

    DEFAULT CHR_lt:=chr(60)
    DEFAULT CHR_gt:=chr(62)
    DEFAULT CHR_Amp:=chr(38)
    DEFAULT CHR_Apos:=chr(39)
    DEFAULT CHR_Quot:=chr(34)
    DEFAULT CHR_PTeV:=chr(59)

    return(self)

method ClassName() class JSONArray
    self:cClassName:="JSONARRAY"
    return(self:cClassName)

method FromINI(cINIStr,cIgnoreToken) class JSONArray

    local cJSON         as character
    local cINIFile      as character
    local cINIFullPath  as character

    local lFromFile     as logical

    paramtype cINIStr       as character
    paramtype cIgnoreToken  as character optional

    begin sequence

        lFromFile:=file(cINIStr)
        if (!lFromFile)
            self:lHasError:=(!dirTools():MakeDir("\tmp\"))
            if (self:lHasError)
                self:SetErrorMsg("Unable to create work directory :: [\temp\]")
                cJSON:="{"
                cJSON+=self:ToJSON("error")
                cJSON+=":"
                cJSON+=self:ToJSON(self:GetErrorMsg())
                cJSON+="}"
                break
            endif
            cINIFullPath:="\tmp\"
            cINIFile:=criaTrab(nil,.F.)
            cINIFullPath+=cINIFile
            cINIFullPath+=".ini"
            while file(cINIFullPath)
                cINIFile:=__Soma1(cINIFile)
                cINIFullPath:="\tmp\"
                cINIFullPath+=cINIFile
                cINIFullPath+=".ini"
            end while
            self:lHasError:=MemoWrite(cINIFullPath,cINIStr)
            if (self:lHasError)
                self:SetErrorMsg("Unable to create work file :: ["+cINIFullPath+"]")
                cJSON:="{"
                cJSON+=self:ToJSON("error")
                cJSON+=":"
                cJSON+=self:ToJSON(self:GetErrorMsg())
                cJSON+="}"
                break
            endif
        else
            cINIFullPath:=cINIStr
        endif

        cJSON:=self:ReadINIFile(cINIFullPath,cIgnoreToken)

        if (!lFromFile)
            if (!empty(cINIFullPath))
                if (file(cINIFullPath))
                    fErase(cINIFullPath)
                endif
            endif
        endif

    end sequnce

    return(cJSON)

method FromXML(cXMLstr,cAttrSuffix,cURL,cEncoding,nOptions,lNameSpaces) class JSONArray

    local aChildArray   as array
    local aAttributes   as array
    local aNameSpaces   as array

    local cExt          as character
    local cFile         as character
    local cPath         as character
    local cDrive        as character
    local cName         as character
    local cJSON         as character
    local cAttValue     as character
    local cAttribute    as character

    local nAttribute    as numeric
    local nAttributes   as numeric

    local nNameSpace    as numeric
    local nNameSpaces   as numeric

    local lFromFile     as logical
    local lCopyFile     as logical
    local lXMLHasNode   as logical

    local oTXMLManager  as object

    paramtype cXMLstr   as character

    DEFAULT cAttrSuffix:="@"
    paramtype cAttrSuffix as character optional

    paramtype cURL  as character optional
    paramtype cEncoding  as character optional
    paramtype nOptions  as numeric optional
    DEFAULT lNameSpaces:=.T.
    paramtype lNameSpaces as logical optional

    if (lNameSpaces)
        private apNameSpaces as array
        apNameSpaces:=Array(0)
    endif

    oTXMLManager:=TXMLManager():New()
    lFromFile:=(!("<"$cXMLstr))
    if (lFromFile)
        lFromFile:=file(cXMLstr)
        if (lFromFile)
            lCopyFile:=dirTools():MakeDir("\tmp\")
            if (lCopyFile)
                cExt:=""
                cFile=""
                cPath:=""
                cDrive=""
                SplitPath(cXMLstr,@cDrive,@cPath,@cFile,@cExt)
                cFile:=("\tmp\"+cFile+cExt)
                lCopyFile:=__CopyFile(cXMLstr,cFile)
            endif
            lFromFile:=lCopyFile
            if (lFromFile)
                lFromFile:=oTXMLManager:ReadFile(cFile,cEncoding,nOptions)
            else
                cXMLstr:=cTools():ReadMemo(cXMLstr)
            endif
        endif
    endif
    if ((lFromFile).or.(oTXMLManager:Read(cXMLstr,cURL,cEncoding,nOptions)))
        lXMLHasNode:=.T.
        if (lNameSpaces)
            aNameSpaces:=Array(0)
        endif
        aAttributes:=Array(0)
        while (lXMLHasNode)
            cName:=oTXMLManager:cName
            self[#cName]:=Array(#)
            if (lNameSpaces)
                aNameSpaces:=oTXMLManager:DOMGetNsList()
            endif
            if (oTXMLManager:DOMHasAtt())
                aAttributes:=oTXMLManager:DOMGetAttArray()
            else
                aSize(aAttributes,0)
            endif
            if (oTXMLManager:DOMHasChildNode())
                if (lNameSpaces)
                    aSize(apNameSpaces,0)
                endif
                aChildArray:=oTXMLManager:XPathGetChildArray(oTXMLManager:cPath)
                cName:=oTXMLManager:cName
                self[#cName]:=FromXML(aChildArray,oTXMLManager,cAttrSuffix,lNameSpaces)
            endif
            if (lNameSpaces)
                nNameSpaces:=len(aNameSpaces)
                for nNameSpace:=1 to nNameSpaces
                    cAttValue:=aNameSpaces[nNameSpace][2]
                    cAttribute:=(cAttrSuffix+aNameSpaces[nNameSpace][1])
                    self[#cAttribute]:=cAttValue
                next nAttribute
            endif
            nAttributes:=len(aAttributes)
            for nAttribute:=1 to nAttributes
                cAttValue:=aAttributes[nAttribute][2]
                cAttribute:=(cAttrSuffix+aAttributes[nAttribute][1])
                self[#cAttribute]:=cAttValue
            next nAttribute
            lXMLHasNode:=oTXMLManager:DOMHasNextNode()
            if (lXMLHasNode)
                lXMLHasNode:=oTXMLManager:DOMNextNode()
            endif
        end while
        if (lFromFile)
            if (lCopyFile)
                fErase(cFile)
            endif
        endif
        cJSON:=self:ToJSON(self)
    else
        self:lHasError:=.T.
        self:SetErrorMsg(oTXMLManager:Error())
        cJSON:="{"
        cJSON+=self:ToJSON("error")
        cJSON+=":"
        cJSON+=self:ToJSON(self:GetErrorMsg())
        cJSON+="}"
    endif

    self:FromJSON(cJSON)

    return(cJSON)

static function FromXML(aChildArray as array,oXMLNode as object,cAttrSuffix as character,lNameSpaces as logical) as object

    local aXMLChild     as array
    local aAttributes   as array
    local aNameSpaces   as array

    local cAttValue     as character
    local cAttribute    as character

    local cXMLName      as character
    local cXMLPath      as character
    local cXMLValue     as character

    local nChild        as numeric
    local nChilds       as numeric
    local nChildAT      as numeric
    local nChildCount   as numeric

    local nNameSpace    as numeric
    local nNameSpaces   as numeric

    local nAttribute    as numeric
    local nAttributes   as numeric

    local oJSONNode     as object

    oJSONNode:=Array(#)
    nChilds:=len(aChildArray)
    for nChild:=1 to nChilds
        cXMLName:=aChildArray[nChild][1]
        cXMLPath:=aChildArray[nChild][2]
        cXMLValue:=aChildArray[nChild][3]
        if (lNameSpaces)
            aNameSpaces:=oXMLNode:XPathGetNsList(cXMLPath)
            /*
                TODO: Temporary workaround because there are no methods in TXMLManager 
                      that check the NameSpace (equivalent to XPathHasAtt or DOMHasAtt)
            */                
            if (aScan(&("apNameSpaces"),{|aNS|(aUtils():Compare(aNS[1],aNameSpaces).and.(aNS[2]$cXMLPath))})==0)
                aAdd(&("apNameSpaces"),{aNameSpaces,cXMLPath})
            else
                aSize(aNameSpaces,0)
            endif
        endif
        nChildCount:=if(oXMLNode:DOMHasChildNode(),oXMLNode:XPathChildCount(cXMLPath),0)
        if (nChildCount>0)
            aXMLChild:=oXMLNode:XPathGetChildArray(cXMLPath)
            if ("["$cXMLPath)
                if (!(valType(oJSONNode[#cXMLName])=="A"))
                    oJSONNode[#cXMLName]:=Array(0)
                endif
                aAdd(oJSONNode[#cXMLName],FromXML(aXMLChild,oXMLNode,cAttrSuffix,lNameSpaces))
                nChildAT:=len(oJSONNode[#cXMLName])
                if (lNameSpaces)
                    nNameSpaces:=len(aNameSpaces)
                    for nNameSpace:=1 to nNameSpaces
                        cAttValue:=aNameSpaces[nNameSpace][2]
                        cAttribute:=(cAttrSuffix+aNameSpaces[nNameSpace][1])
                        oJSONNode[#cXMLName][nChildAT][#cAttribute]:=cAttValue
                    next nAttribute
                endif
                if (oXMLNode:XPathHasAtt(cXMLPath))
                    aAttributes:=oXMLNode:XPathGetAttArray(cXMLPath)
                    nAttributes:=len(aAttributes)
                    for nAttribute:=1 to nAttributes
                        cAttValue:=aAttributes[nAttribute][2]
                        cAttribute:=(cAttrSuffix+aAttributes[nAttribute][1])
                        oJSONNode[#cXMLName][nChildAT][#cAttribute]:=cAttValue
                    next nAttribute
                endif
            else
                oJSONNode[#cXMLName]:=FromXML(aXMLChild,oXMLNode,cAttrSuffix,lNameSpaces)
                if (lNameSpaces)
                    nNameSpaces:=len(aNameSpaces)
                    for nNameSpace:=1 to nNameSpaces
                        cAttValue:=aNameSpaces[nNameSpace][2]
                        cAttribute:=(cAttrSuffix+aNameSpaces[nNameSpace][1])
                        oJSONNode[#cAttribute]:=cAttValue
                    next nAttribute
                endif
                if (oXMLNode:XPathHasAtt(cXMLPath))
                    aAttributes:=oXMLNode:XPathGetAttArray(cXMLPath)
                    nAttributes:=len(aAttributes)
                    for nAttribute:=1 to nAttributes
                        cAttValue:=aAttributes[nAttribute][2]
                        cAttribute:=(cAttrSuffix+aAttributes[nAttribute][1])
                        oJSONNode[#cAttribute]:=cAttValue
                    next nAttribute
                endif
            endif
        else
            oJSONNode[#cXMLName]:=cXMLValue
        endif
    next nChild

return(oJSONNode)

/*
static function: FromJSON(cJSONstr)
Converts from a JSON string into any value it holds

Example:
----
cJSON:='{"Products": [{"Name": "Water","Cost": 1.3},{"Name": "Bread","Cost": 4e-1}],"Users": [{"Name": "Arthur","Comment": "Hello\" \\World"}]}'

aaBusiness:=FromJSON(cJSON)

alert(aaBusiness[#'Products'][1][#'Name']) // returns -> Water

alert(aaBusiness[#'Products'][2][#'Cost']) // returns -> 0.4

alert(aaBusiness[#'Users'][1][#'Comment']) // returns -> Hello" \World
----

Additional Info:
Numbers accept the Scientific E Notation
   234e-7 = 0.0000234
   57e3   = 57000
I don't know how I can make an Unicode or UTF-8 character in AdvPL,
   So,the JSON \uXXXX converts an ASCII code. Values outside the ASCII table becomes '?' (quotation marks).

@param cJSONstr - The JSON string you want to convert from
@return - The converted JSON string,it can be any type. Or nil in case of a bad formatted JSON string.
*/
method FromJSON(cJSONstr) class JSONArray
    local aSelf             as array
    local cData             as character
    local lGetObjSuperClass as logical
    local nD                as numeric
    local nJ                as numeric
    paramtype cJSONstr      as character
    lGetObjSuperClass:=.F.
    aSelf:=classDataArr(self,lGetObjSuperClass)
    FromJSON(@self,cJSONstr)
    private pSelf as object
    pSelf:=self
    nJ:=len(aSelf)
    for nD:=1 to nJ
        cData:="pSelf"
        cData+=":"
        cData+=aSelf[nD][1]
        &(cData):=aSelf[nD][2]
    next nD
return(self)

static function FromJSON(oJSONArray as object,cJSONstr as character) as object

    local aJSONVal  as array

    local cType     as character

    local nRet      as numeric

    paramtype cJSONstr as character

    aJSONVal:=GetJSONVal(cJSONstr)

    nRet:=aJSONVal[2]
    if (nRet>=0)
        cType:=valType(aJSONVal[1])
        do case
        case (cType=="O")
            oJSONArray:SetFromObject(aJSONVal[1])
        otherwise
            oJSONArray[#"JSONArray"]:=aJSONVal[1]
        endcase
    else
        oJSONArray:lHasError:=.T.
        oJSONArray[#"error"]:="Error in JSON Parser"
        oJSONArray:SetErrorMsg(oJSONArray[#"error"])
    endif

return(oJSONArray)

method FromHashMap(oJSONHashMap) class JSONArray
    paramtype oJSONHashMap as object
    self:SetFromHashMap(oJSONHashMap)
return(self)

method JSONParser(cJSONstr,lSetFromObject) class JSONArray

    local aJSONParser   as array

    local lJSONParser   as logical

    local nATJSON       as numeric
    local nJSONstr      as numeric

    local oJSONParser   as object
    local oJSONHashMap  as object

    paramtype cJSONstr as character
    DEFAULT lSetFromObject:=.T.
    paramtype lSetFromObject as logical optional

    nJSONstr:=len(cJSONstr)
    aJSONParser:=Array(0)
    nATJSON:=0

    oJSONParser:=TJSONParser():New()

    lJSONParser:=oJSONParser:JSON_Hash(cJSONstr,nJSONstr,@aJSONParser,@nATJSON,@oJSONHashMap)

    if (!lJSONParser)
        self[#"error"]:="JSON Len :: ["+NToS(nJSONstr)+"], Error AT :: ["+NToS(nATJSON+1)+"]"
        self:lHasError:=.T.
        self:SetErrorMsg(self[#"error"])
    else
        aSize(aJSONParser,0)
        if (lSetFromObject)
            self:SetFromObject(oJSONHashMap)
        else
            self:FromHashMap(oJSONHashMap)
        endif
    endif

return(self)

method JSONParserFile(cFileName,lSetFromObject) class JSONArray

    local cJSON    as character

    DEFAULT lSetFromObject:=.T.
    paramtype lSetFromObject as logical optional

    begin sequence

        if (!File(cFileName))
            self[#"error"]:="File ["+cFileName+"] does not exist."
            self:lHasError:=.T.
            self:SetErrorMsg(self[#"error"])
            break
        endif

        cJSON:=cTools():ReadMemo(cFileName)

        self:JSONParser(cJSON,lSetFromObject)

    end sequence

return(self)

/*
static function: ToJSON(uAnyVar)
Converts AdvPLs value into a JSON string
Accepted values: Strings,Numbers,Logicals,nil,Arrays and Associative Arrays (jsonhash Objects)

Example:
----
aaBusiness:=Array(#)
aaBusiness[#'Products']:=Array(2)
aaBusiness[#'Products'][1]:=Array(#)
aaBusiness[#'Products'][1][#'Name']:="Water"
aaBusiness[#'Products'][1][#'Cost']:=1.3
aaBusiness[#'Products'][2]:=Array(#)
aaBusiness[#'Products'][2][#'Name']:="Bread"
aaBusiness[#'Products'][2][#'Cost']:=0.4
aaBusiness[#'Users']:=Array(1)
aaBusiness[#'Users'][1]:=Array(#)
aaBusiness[#'Users'][1][#'Name']:="Arthur"
aaBusiness[#'Users'][1][#'Comment']:='Hello" \World'


alert(ToJSON(aaBusiness))

 returns:
 {"Products": [{"Name": "Water","Cost": 1.3},{"Name": "Bread","Cost": 0.4}],"Users": [{"Name": "Arthur","Comment": "Hello\" \\World"}]}
----

@param uAnyVar - The value you want to convert to a JSON string
@return string - JSON string
*/

method ToJSON(uAnyVar) class JSONArray

    local cJSON     as character

    local uSelf

    DEFAULT uAnyVar:=self

    if (valType(uAnyVar)=="O")
        if (GetClassName(uAnyVar)$CLS_NAME_THASH)
            if (self:GetAT("JSONArray")>0)
                uSelf:=self:Get("JSONArray")
            endif
        endif
    endif

    DEFAULT uSelf:=uAnyVar

    cJSON:=__ToJSON(uSelf,self)

    cJSON:=cTools():UTF8(cJSON,@self:lUTF8,@self:lNoAccent,@self:lTrimSpace)

    if (self:lPrettify)
        cJSON:=cTools():StrPrettify(cJSON,3,self:nPrettify)
    endif

return(cJSON)

static function __ToJSON(uAnyVar,oJSONArray as object) as character

    local aData                 as array

    local cJSON                 as character
    local cType                 as character

    local cHashFile             as character
    local cClsNValue            as character

    local cClassName            as character
    local cAttribute            as character

    local lHashAsFile           as logical
    local lGetObjSuperClass     as logical
    local lHasSectionEnabled    as logical

    local nC                    as numeric
    local nS                    as numeric
    local nD                    as numeric
    local nJ                    as numeric

    local nTimeStamp            as numeric

    local oSetHashMap           as object

    local uKey
    local uValue

    nTimeStamp:=oJSONArray:nTimeStamp
    lGetObjSuperClass:=oJSONArray:lGetObjSuperClass

    begin sequence

        cType:=valType(uAnyVar)

        do case
        case (cType=="C")
            if (("thash"$uAnyVar).and.(file(uAnyVar)))
                uValue:=oJSONArray:RestDataHash("",uAnyVar,"A","")
                cJSON:=__ToJSON(uValue,oJSONArray)
            else
                cJSON:='"'+oJSONArray:EscpJSONStr(uAnyVar)+'"'
            endif
            break
        case (cType=="N")
            cJSON:=cValToChar(uAnyVar)
            break
        case (cType=="L")
            cJSON:=if(uAnyVar,"true","false")
            break
        case (cType=="D")
            if ((valType(nTimeStamp)=="N").and.(nTimeStamp>0))
                cJSON:='"'+FWTimeStamp(nTimeStamp,uAnyVar)+'"'
            else
                cJSON:='"'+DtoS(uAnyVar)+'"'
            endif
            break
        case (cType=="U")
            cJSON:="null"
            break
        case (cType=="A")
            if (oJSONArray:ArrayIsHashObject(uAnyVar))
                uValue:=oJSONArray:ArrayToHashObject(uAnyVar)
                cJSON:=__ToJSON(uValue,oJSONArray)
            else
                cJSON:=''
                cJSON+='['
                nJ:=len(uAnyVar)
                for nD:=1 to nJ
                    uValue:=uAnyVar[nD]
                    cJSON+=__ToJSON(uValue,oJSONArray)
                    cJSON+=','
                next nD
                cJSON:=cTools():RightCharRemove(cJSON,',')
                cJSON+=']'
            endif
            break
        case (cType=="B")
            cJSON:='"'+getCBSource(uAnyVar)+'"'
            break
        case (cType=="O")
            cClassName:=GetClassName(uAnyVar)
            if (cClassName=="THASHMAP")
                oSetHashMap:=Array(#)
                oSetHashMap:SetFromHashMap(uAnyVar)
                uAnyVar:=oSetHashMap
                cClassName:=GetClassName(uAnyVar)
            endif
            if (cClassName$CLS_NAME_THASH)
                if (uAnyVar:GetAT("JSONArray")>0)
                    aData:=uAnyVar:Get("JSONArray")
                else
                    aData:=uAnyVar:GetHashArray()
                endif
                lHashAsFile:=uAnyVar:lHashAsFile()
                lHasSectionEnabled:=uAnyVar:HasSectionEnabled()
            else
                aData:=classDataArr(uAnyVar,lGetObjSuperClass)
                lHashAsFile:=.F.
                lHasSectionEnabled:=.F.
            endif
            cJSON:=''
            if (lHasSectionEnabled)
                cJSON+='['
                nC:=len(aData)
                for nS:=1 to nC
                    cAttribute:=aData[nS][HASH_SECTION_POSITION]
                    cJSON+='{'
                    cJSON+=__ToJSON(cAttribute,oJSONArray)
                    cJSON+=':'
                    cJSON+='{'
                    nJ:=len(aData[nS][HASH_PROPERTY_POSITION])
                    for nD:=1 to nJ
                        uKey:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_KEY]
                        cAttribute:=uKey
                        cHashFile:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_FILE]
                        if ((lHashAsFile).or.(!empty(cHashFile)))
                            uValue:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_VALUE]
                            if (uValue)
                                cType:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_TYPE]
                                cClsNValue:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_CLSNAME]
                                uValue:=uAnyVar:RestDataHash(uKey,cHashFile,cType,cClsNValue)
                            endif
                        else
                            uValue:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_VALUE]
                        endif
                        cJSON+='"'
                        cJSON+=oJSONArray:EscpJSONStr(cAttribute)
                        cJSON+='":'
                        cJSON+=__ToJSON(uValue,oJSONArray)
                        cJSON+=','
                    next nD
                    cJSON:=cTools():RightCharRemove(cJSON,',')
                    cJSON+='}'
                    cJSON+='}'
                    cJSON+=','
                next nS
                cJSON:=cTools():RightCharRemove(cJSON,',')
                cJSON+=']'
                break
            endif /*uAnyVar:HasSectionEnabled()*/
            cJSON+='{'
            nJ:=len(aData)
            for nD:=1 to nJ
                uKey:=aData[nD][HASH_PROPERTY_KEY]
                cAttribute:=aData[nD][HASH_PROPERTY_KEY]
                cHashFile:=aData[nD][HASH_PROPERTY_FILE]
                if ((lHashAsFile).or.(!empty(cHashFile)))
                    uValue:=aData[nD][HASH_PROPERTY_VALUE]
                    if (uValue)
                        cType:=aData[nD][HASH_PROPERTY_TYPE]
                        cClsNValue:=aData[nD][HASH_PROPERTY_CLSNAME]
                        uValue:=uAnyVar:RestDataHash(uKey,cHashFile,cType,cClsNValue)
                    endif
                else
                    uValue:=aData[nD][HASH_PROPERTY_VALUE]
                endif
                cJSON+='"'
                cJSON+=oJSONArray:EscpJSONStr(cAttribute)
                cJSON+='":'
                cJSON+=__ToJSON(uValue,oJSONArray)
                cJSON+=','
            next nD
            cJSON:=cTools():RightCharRemove(cJSON,',')
            cJSON+='}'
        endcase
    end sequence

    if (valType(oSetHashMap)=="O")
        oSetHashMap:=oSetHashMap:FreeObj()
    endif

    DEFAULT cJSON:="Unknown Data Type ("+cType+")"

return(cJSON)

method ToJSONFile(uAnyVar,cJSONFile) class JSONArray

    local cJSON       as character
    local cJSONTmp    as character

    local lJSONFile   as logical

    local nJSONTmp    as numeric

    local uSelf

    DEFAULT uAnyVar:=self

    lJSONFile:=.F.

    begin sequence

        if (valType(uAnyVar)=="O")
            if (GetClassName(uAnyVar)$CLS_NAME_THASH)
                if (self:GetAT("JSONArray")>0)
                    uSelf:=self:Get("JSONArray")
                endif
            endif
        endif

        DEFAULT uSelf:=uAnyVar

        self:lHasError:=(!dirTools():MakeDir("\json\"))
        if (self:lHasError)
            self:SetErrorMsg("Unable to create work directory :: [\json\]")
            cJSON:="{"
            cJSON+=self:ToJSON("error")
            cJSON+=":"
            cJSON+=self:ToJSON(self:GetErrorMsg())
            cJSON+="}"
            break
        endif

        self:lHasError:=(!dirTools():MakeDir(cJSONFile))
        if (self:lHasError)
            self:SetErrorMsg("Unable to create work directory :: ["+cJSONFile+"]")
            cJSON:="{"
            cJSON+=self:ToJSON("error")
            cJSON+=":"
            cJSON+=self:ToJSON(self:GetErrorMsg())
            cJSON+="}"
            break
        endif

        cJSONTmp:="\json\"
        cJSONTmp+=criaTrab(nil,.F.)
        while (file(cJSONTmp))
            cJSONTmp:=__Soma1(cJSONTmp)
        end while

        nJSONTmp:=fCreate(cJSONTmp)
        self:lHasError:=(!(nJSONTmp>=0))
        if (self:lHasError)
            self:SetErrorMsg("Unable to create work file :: ["+cJSONTmp+"] Error :: ["+NToS(fError())+"]")
            cJSON:="{"
            cJSON+=self:ToJSON("error")
            cJSON+=":"
            cJSON+=self:ToJSON(self:GetErrorMsg())
            cJSON+="}"
            break
        endif

        lJSONFile:=file(cJSONTmp)
        if (!lJSONFile)
            break
        endif

        private c__JSONBuffer as character
        c__JSONBuffer:=""

        __ToJSONFile(nJSONTmp,uSelf,self)

        if (!empty(c__JSONBuffer))
            fWrite(nJSONTmp,c__JSONBuffer)
            c__JSONBuffer:=""
        endif

        fClose(nJSONTmp)

        lJSONFile:=__CopyFile(cJSONTmp,cJSONFile)

        fErase(cJSONTmp)

        self:lHasError:=(!lJSONFile)
        if (self:lHasError)
            self:SetErrorMsg("Unable to create file :: ["+cJSONFile+"]")
            cJSON:="{"
            cJSON+=self:ToJSON("error")
            cJSON+=":"
            cJSON+=self:ToJSON(self:GetErrorMsg())
            cJSON+="}"
            break
        endif

    end sequence

return(lJSONFile)

    static procedure __ToJSONFile(nJSONTmp as numeric,uAnyVar,oJSONArray as object)

    local aData                 as array

    local cJSON                 as character
    local cType                 as character

    local cHashFile             as character
    local cClsNValue            as character

    local cClassName            as character
    local cAttribute            as character

    local lHashAsFile           as logical
    local lGetObjSuperClass     as logical
    local lHasSectionEnabled    as logical

    local nC                    as numeric
    local nS                    as numeric
    local nD                    as numeric
    local nJ                    as numeric

    local nTimeStamp            as numeric

    local oSetHashMap           as object

    local uKey
    local uValue

    nTimeStamp:=oJSONArray:nTimeStamp
    lGetObjSuperClass:=oJSONArray:lGetObjSuperClass

    begin sequence

        cType:=valType(uAnyVar)

        do case
        case (cType=="C")
            if (("thash"$uAnyVar).and.(file(uAnyVar)))
                uValue:=oJSONArray:RestDataHash("",uAnyVar,"A","")
                __ToJSONFile(nJSONTmp,uValue,oJSONArray)
            else
                cJSON:='"'+oJSONArray:EscpJSONStr(uAnyVar)+'"'
                cJSON:=cTools():UTF8(cJSON,@oJSONArray:lUTF8,@oJSONArray:lNoAccent,@oJSONArray:lTrimSpace)
                c__JSONBuffer+=cJSON
            endif
            break
        case (cType=="N")
            cJSON:=cValToChar(uAnyVar)
            c__JSONBuffer+=cJSON
            break
        case (cType=="L")
            cJSON:=if(uAnyVar,"true","false")
            c__JSONBuffer+=cJSON
            break
        case (cType=="D")
            if ((valType(nTimeStamp)=="N").and.(nTimeStamp>0))
                cJSON:='"'+FWTimeStamp(nTimeStamp,uAnyVar)+'"'
            else
                cJSON:='"'+DtoS(uAnyVar)+'"'
            endif
            c__JSONBuffer+=cJSON
            break
        case (cType=="U")
            c__JSONBuffer+="null"
            break
        case (cType=="A")
            if (oJSONArray:ArrayIsHashObject(uAnyVar))
                uValue:=oJSONArray:ArrayToHashObject(uAnyVar)
                __ToJSONFile(nJSONTmp,uValue,oJSONArray)
            else
                c__JSONBuffer+='['
                nJ:=len(uAnyVar)
                for nD:=1 to nJ
                    uValue:=uAnyVar[nD]
                    __ToJSONFile(nJSONTmp,uValue,oJSONArray)
                    if (nD<nJ)
                        c__JSONBuffer+=','
                    endif
                    if (len(c__JSONBuffer)>=1024)
                        fWrite(nJSONTmp,c__JSONBuffer)
                        c__JSONBuffer:=""
                    endif
                next nD
                c__JSONBuffer+=']'
            endif
            break
        case (cType=="B")
            cJSON:='"'+getCBSource(uAnyVar)+'"'
            c__JSONBuffer+=cJSON
            break
        case (cType=="O")
            cClassName:=GetClassName(uAnyVar)
            if (cClassName=="THASHMAP")
                oSetHashMap:=Array(#)
                oSetHashMap:SetFromHashMap(uAnyVar)
                uAnyVar:=oSetHashMap
                cClassName:=GetClassName(uAnyVar)
            endif
            if (cClassName$CLS_NAME_THASH)
                if (uAnyVar:GetAT("JSONArray")>0)
                    aData:=uAnyVar:Get("JSONArray")
                else
                    aData:=uAnyVar:GetHashArray()
                endif
                lHashAsFile:=uAnyVar:lHashAsFile()
                lHasSectionEnabled:=uAnyVar:HasSectionEnabled()
            else
                aData:=classDataArr(uAnyVar,lGetObjSuperClass)
                lHashAsFile:=.F.
                lHasSectionEnabled:=.F.
            endif
            if (lHasSectionEnabled)
                c__JSONBuffer+='['
                nC:=len(aData)
                for nS:=1 to nC
                    cAttribute:=aData[nS][HASH_SECTION_POSITION]
                    c__JSONBuffer+='{'
                    __ToJSONFile(nJSONTmp,cAttribute,oJSONArray)
                    c__JSONBuffer+=':'
                    c__JSONBuffer+='{'
                    nJ:=len(aData[nS][HASH_PROPERTY_POSITION])
                    for nD:=1 to nJ
                        uKey:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_KEY]
                        cAttribute:=uKey
                        cHashFile:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_FILE]
                        if ((lHashAsFile).or.(!empty(cHashFile)))
                            uValue:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_VALUE]
                            if (uValue)
                                cType:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_TYPE]
                                cClsNValue:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_CLSNAME]
                                uValue:=uAnyVar:RestDataHash(uKey,cHashFile,cType,cClsNValue)
                            endif
                        else
                            uValue:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_VALUE]
                        endif
                        c__JSONBuffer+='"'
                        cJSON:=oJSONArray:EscpJSONStr(cAttribute)
                        cJSON:=cTools():UTF8(cJSON,@oJSONArray:lUTF8,@oJSONArray:lNoAccent,@oJSONArray:lTrimSpace)
                        c__JSONBuffer+=cJSON
                        c__JSONBuffer+='":'
                        __ToJSONFile(nJSONTmp,uValue,oJSONArray)
                        if (nD<nJ)
                            c__JSONBuffer+=','
                        endif
                        if (len(c__JSONBuffer)>=1024)
                            fWrite(nJSONTmp,c__JSONBuffer)
                            c__JSONBuffer:=""
                        endif
                    next nD
                    c__JSONBuffer+='}'
                    c__JSONBuffer+='}'
                    if (nS<nC)
                        c__JSONBuffer+=','
                    endif
                    if (len(c__JSONBuffer)>=1024)
                        fWrite(nJSONTmp,c__JSONBuffer)
                        c__JSONBuffer:=""
                    endif
                next nS
                c__JSONBuffer+=']'
                break
            endif /*uAnyVar:HasSectionEnabled()*/
            c__JSONBuffer+='{'
            nJ:=len(aData)
            for nD:=1 to nJ
                uKey:=aData[nD][HASH_PROPERTY_KEY]
                cAttribute:=aData[nD][HASH_PROPERTY_KEY]
                cHashFile:=aData[nD][HASH_PROPERTY_FILE]
                if ((lHashAsFile).or.(!empty(cHashFile)))
                    uValue:=aData[nD][HASH_PROPERTY_VALUE]
                    if (uValue)
                        cType:=aData[nD][HASH_PROPERTY_TYPE]
                        cClsNValue:=aData[nD][HASH_PROPERTY_CLSNAME]
                        uValue:=uAnyVar:RestDataHash(uKey,cHashFile,cType,cClsNValue)
                    endif
                else
                    uValue:=aData[nD][HASH_PROPERTY_VALUE]
                endif
                c__JSONBuffer+='"'
                cJSON:=oJSONArray:EscpJSONStr(cAttribute)
                cJSON:=cTools():UTF8(cJSON,@oJSONArray:lUTF8,@oJSONArray:lNoAccent,@oJSONArray:lTrimSpace)
                c__JSONBuffer+=cJSON
                c__JSONBuffer+='":'
                __ToJSONFile(nJSONTmp,uValue,oJSONArray)
                if (nD<nJ)
                    c__JSONBuffer+=','
                endif
                if (len(c__JSONBuffer)>=1024)
                    fWrite(nJSONTmp,c__JSONBuffer)
                    c__JSONBuffer:=""
                endif
            next nD
            c__JSONBuffer+='}'
        endcase
    end sequence

    if (len(c__JSONBuffer)>=1024)
        fWrite(nJSONTmp,c__JSONBuffer)
        c__JSONBuffer:=""
    endif

    if (valType(oSetHashMap)=="O")
        oSetHashMap:=oSetHashMap:FreeObj()
    endif

return

method ToXML(cXMLRoot,cAttrSuffix,lArrayToList) class JSONArray

    local cXML          as character
    local cToXML        as character
    local cXMLNew       as character
    local cEncode       as character
    local cVersion      as character

    local oTXMLManager  as object

    local uSelf

    paramtype cXMLRoot as character optional
    DEFAULT cAttrSuffix:="@"
    paramtype cAttrSuffix as character optional
    lArrayToList:=.F.
    paramtype lArrayToList as logical optional

    if (self:lUTF8)
        cEncode:='encoding="UTF-8"'
    endif

    cVersion:='"1.0"'
    cXML:="<?xml version="+cVersion+" "+cEncode+"?>"
    DEFAULT cXMLRoot:="xml"
    cXML+="<"+cXMLRoot+">"
    if (self:GetAT("JSONArray")>0)
        uSelf:=self:Get("JSONArray")
    else
        uSelf:=self
    endif
    private cXMLFull as character
    cXMLFull:=""
    private aXMLAttr as array
    aXMLAttr:=Array(0)
    __ToXML(uSelf,uSelf,@lArrayToList,@cAttrSuffix)
    cToXML:=cXMLFull
    cToXML:=strTran(cToXML,"@__NAMESPACE_ND__@","")
    cToXML:=strTran(cToXML,"@__NAMESPACE_NS__@","")
    cToXML:=strTran(cToXML,"@__ATTRIBUTE_ND__@","")
    cToXML:=strTran(cToXML,"@__ATTRIBUTE_NS__@","")
    cXML+=cToXML
    cXML+="</"+cXMLRoot+">"

    //begin TODO: check for attributes and namespace
    if (("<"+cAttrSuffix)$cXML)
        cXML:=StrTran(cXML,("<"+cAttrSuffix),"<")
    endif
    //end TODO: check for attributes and namespace

    cXML:=cTools():UTF8(cXML,@self:lUTF8,@self:lNoAccent,@self:lTrimSpace)

    if (self:lPrettify)
        cXML:=cTools():StrPrettify(cXML,1,self:nPrettify)
    endif

    oTXMLManager:=TXMLManager():New()
    if (oTXMLManager:Parse(cXML))
        cXMLNew:=oTXMLManager:Save2String()
        if (!Empty(cXMLNew))
            cXML:=cXMLNew
        endif
    endif

return(cXML)

static function __ToXML(uAnyVar,oJSONArray,lArrayToList as logical,cAttrSuffix as character) as character

    local aData                    as array

    local cXML                  as character
    local cType                 as character
    local cXMLAttr              as character
    local cHashFile             as character
    local cClsNValue            as character
    local cAttribute            as character
    local cClassName            as character

    local lHashAsFile           as logical
    local lAttrSuffixNS         as logical
    local lAttrSuffixND         as logical
    local lGetObjSuperClass     as logical
    local lHasSectionEnabled    as logical

    local nC                    as numeric
    local nS                    as numeric
    local nD                    as numeric
    local nJ                    as numeric
    local nAT                   as numeric

    local nStack                as numeric
    local nATAttr               as numeric
    local nXMLAttr              as numeric
    local nStackAttr            as numeric
    local nTimeStamp            as numeric

    local oSetHashMap           as object

    local uKey
    local uValue

    nStack:=StackTools():StackCount("__ToXML")

    nTimeStamp:=oJSONArray:nTimeStamp
    lGetObjSuperClass:=oJSONArray:lGetObjSuperClass

    begin sequence

        cType:=valType(uAnyVar)

        do case
        case (cType=="C")
            if (("thash"$uAnyVar).and.(file(uAnyVar)))
                uValue:=oJSONArray:RestDataHash("",uAnyVar,"A","")
                cJSON:=__ToXML(uValue,@oJSONArray,@lArrayToList,@cAttrSuffix)
            else
                cXML:=uAnyVar
            endif
            break
        case (cType=="N")
            cXML:=cValToChar(uAnyVar)
            break
        case (cType=="L")
            cXML:=if(uAnyVar,"true","false")
            break
        case (cType=="D")
            if ((valType(nTimeStamp)=="N").and.(nTimeStamp>0))
                cXML:=FWTimeStamp(nTimeStamp,uAnyVar)
            else
                cXML:=DtoS(uAnyVar)
            endif
            break
        case (cType=="U")
            cXML:="null"
            break
        case (cType=="A")
            if (oJSONArray:ArrayIsHashObject(uAnyVar))
                uValue:=oJSONArray:ArrayToHashObject(uAnyVar)
                cXML:=__ToXML(uValue,@oJSONArray,@lArrayToList,@cAttrSuffix)
            else
                cXML:=""
                if (lArrayToList)
                    cXML+="<list>"
                endif
                nJ:=len(uAnyVar)
                for nD:=1 to nJ
                    uValue:=uAnyVar[nD]
                    if (lArrayToList)
                        cXML+='<list id="'+NToS(nD)+'">'
                    endif
                    cXML+=__ToXML(uValue,@oJSONArray,@lArrayToList,@cAttrSuffix)
                    if (lArrayToList)
                        cXML+="</list>"
                    endif
                next nD
                if (lArrayToList)
                    cXML+="</list>"
                endif
            endif
            break
        case (cType=="B")
            cXML:=getCBSource(uAnyVar)
            break
        case (cType=="O")
            cClassName:=GetClassName(uAnyVar)
            if (cClassName=="THASHMAP")
                oSetHashMap:=Array(#)
                oSetHashMap:SetFromHashMap(uAnyVar)
                uAnyVar:=oSetHashMap
                cClassName:=GetClassName(uAnyVar)
            endif
            if (cClassName$CLS_NAME_THASH)
                if (uAnyVar:GetAT("JSONArray")>0)
                    aData:=uAnyVar:Get("JSONArray")
                else
                    aData:=uAnyVar:GetHashArray()
                endif
                lHashAsFile:=uAnyVar:lHashAsFile()
                lHasSectionEnabled:=uAnyVar:HasSectionEnabled()
            else
                aData:=classDataArr(uAnyVar,lGetObjSuperClass)
                lHashAsFile:=.F.
                lHasSectionEnabled:=.F.
            endif
            if (lHasSectionEnabled)
                nC:=len(aData)
                for nS:=1 to nC
                    cAttribute:=aData[nS][HASH_SECTION_POSITION]
                    lAttrSuffixNS:=(cTools():LeftAT(cAttrSuffix,cAttribute)>0)
                    if (!lAttrSuffixNS)
                        cXMLFull+="<"
                        cXMLFull+=cAttribute
                        cXMLFull+=XML_NLS_ATTRIBUTE_NS
                        cXMLFull+=">"
                    endif
                    nJ:=len(aData[nS][HASH_PROPERTY_POSITION])
                    for nD:=1 to nJ
                        uKey:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_KEY]
                        cAttribute:=uKey
                        cHashFile:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_FILE]
                        if ((lHashAsFile).or.(!empty(cHashFile)))
                            uValue:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_VALUE]
                            if (uValue)
                                cType:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_TYPE]
                                cClsNValue:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_CLSNAME]
                                uValue:=uAnyVar:RestDataHash(uKey,cHashFile,cType,cClsNValue)
                            endif
                        else
                            uValue:=aData[nS][HASH_PROPERTY_POSITION][nD][HASH_PROPERTY_VALUE]
                        endif
                        lAttrSuffixND:=(cTools():LeftAT(cAttrSuffix,cAttribute)>0)
                        if ((!lAttrSuffixND).and.!(lAttrSuffixNS))
                            cXMLFull+="<"
                            cXMLFull+=cAttribute
                            nXMLAttr:=Len(cXMLFull)
                            aAdd(aXMLAttr,{nStack,nXMLAttr,.F.})
                            cXMLFull+=XML_NLS_ATTRIBUTE_ND
                            cXMLFull+=">"
                            cXMLFull+=__ToXML(uValue,@oJSONArray,@lArrayToList,@cAttrSuffix)
                            if (nXMLAttr>0)
                                cXMLFull:=stuff(cXMLFull,(nXMLAttr+1),len(XML_NLS_ATTRIBUTE_ND),"")
                            endif
                            cXMLFull+="</"
                            cXMLFull+=cAttribute
                            cXMLFull+=">"
                        else
                            nStackAttr:=nStack
                            nATAttr:=aScan(aXMLAttr,{|e|(e[1]==(--nStackAttr))})
                            if (nXMLAttr==0)
                                while( nStackAttr>0)
                                    nATAttr:=aScan(aXMLAttr,{|e|(e[1]==(--nStackAttr))})
                                end while
                            end while
                            if (nATAttr>0)
                                aXMLAttr[nATAttr][3]:=.T.
                                nXMLAttr:=aXMLAttr[nATAttr][2]
                                cAttribute:=cTools():LeftATRemove(cAttrSuffix,cAttribute,.T.)
                                cXMLAttr:=" "
                                cXMLAttr+=cAttribute
                                cXMLAttr+='="'
                                cXMLAttr+=__ToXML(uValue,@oJSONArray,@lArrayToList,@cAttrSuffix)
                                cXMLAttr+='"'
                                if ("ns"$lower(cAttribute))
                                    nAT:=cTools():LeftAT("@__NAMESPACE_"+if(lAttrSuffixNS,"NS","ND")+"__@",SubStr(cXMLFull,nXMLAttr))
                                    if (nAT>0)
                                        nAT:=nXMLAttr
                                        cXMLFull:=stuff(cXMLFull,nAT,len("@__NAMESPACE_"+if(lAttrSuffixNS,"NS","ND")+"__@"),cXMLAttr)
                                    endif
                                else
                                    nAT:=cTools():LeftAT("@__ATTRIBUTE_"+if(lAttrSuffixNS,"NS","ND"),SubStr(cXMLFull,nXMLAttr))
                                    if (nAT>0)
                                        nAT:=(nXMLAttr+nAT)
                                        cXMLFull:=stuff(cXMLFull,nAT,len("@__ATTRIBUTE_"+if(lAttrSuffixNS,"NS","ND")),cXMLAttr)
                                    endif
                                endif
                            endif
                        endif
                    next nD
                    if (!lAttrSuffixNS)
                        cXMLFull+="</"
                        cXMLFull+=cAttribute
                        cXMLFull+=">"
                    endif
                next nS
            else
                nJ:=len(aData)
                for nD:=1 to nJ
                    uKey:=aData[nD][HASH_PROPERTY_KEY]
                    cAttribute:=uKey
                    cHashFile:=aData[nD][HASH_PROPERTY_FILE]
                    if ((lHashAsFile).or.(!empty(cHashFile)))
                        uValue:=aData[nD][HASH_PROPERTY_VALUE]
                        if (uValue)
                            cType:=aData[nD][HASH_PROPERTY_TYPE]
                            cClsNValue:=aData[nD][HASH_PROPERTY_CLSNAME]
                            uValue:=uAnyVar:RestDataHash(uKey,cHashFile,cType,cClsNValue)
                        endif
                    else
                        uValue:=aData[nD][HASH_PROPERTY_VALUE]
                    endif
                    lAttrSuffixND:=(cTools():LeftAT(cAttrSuffix,cAttribute)>0)
                    if (!lAttrSuffixND)
                        cXMLFull+="<"
                        cXMLFull+=cAttribute
                        nXMLAttr:=Len(cXMLFull)
                        aAdd(aXMLAttr,{nStack,nXMLAttr,.F.})
                        cXMLFull+=XML_NLS_ATTRIBUTE_ND
                        cXMLFull+=">"
                        cXMLFull+=__ToXML(uValue,@oJSONArray,@lArrayToList,@cAttrSuffix)
                        if (nXMLAttr>0)
                            cXMLFull:=stuff(cXMLFull,(nXMLAttr+1),len(XML_NLS_ATTRIBUTE_ND),"")
                        endif
                        cXMLFull+="</"
                        cXMLFull+=cAttribute
                        cXMLFull+=">"
                    else
                        nStackAttr:=nStack
                        nATAttr:=aScan(aXMLAttr,{|e|(e[1]==(--nStackAttr))})
                        if (nXMLAttr==0)
                            while( nStackAttr>0)
                                nATAttr:=aScan(aXMLAttr,{|e|(e[1]==(--nStackAttr))})
                            end while
                        end while
                        if (nATAttr>0)
                            aXMLAttr[nATAttr][3]:=.T.
                            nXMLAttr:=aXMLAttr[nATAttr][2]
                            cAttribute:=cTools():LeftATRemove(cAttrSuffix,cAttribute,.T.)
                            cXMLAttr:=" "
                            cXMLAttr+=cAttribute
                            cXMLAttr+='="'
                            cXMLAttr+=__ToXML(uValue,@oJSONArray,@lArrayToList,@cAttrSuffix)
                            cXMLAttr+='"'
                            if ("ns"$lower(cAttribute))
                                nAT:=cTools():LeftAT("@__NAMESPACE_ND__@",SubStr(cXMLFull,nXMLAttr))
                                if (nAT>0)
                                    nAT:=nXMLAttr
                                    cXMLFull:=stuff(cXMLFull,nAT,len("@__NAMESPACE_ND__@"),cXMLAttr)
                                endif
                            else
                                nAT:=cTools():LeftAT("@__ATTRIBUTE_ND__@",SubStr(cXMLFull,nXMLAttr))
                                if (nAT>0)
                                    nAT:=(nXMLAttr+nAT)
                                    cXMLFull:=stuff(cXMLFull,nAT,len("@__ATTRIBUTE_ND__@"),cXMLAttr)
                                endif
                            endif
                        endif
                    endif
                next nD
            endif
        otherwise
            cXML:="Unknown Data Type ("+cType+")"
        endcase
    end sequence

    if (valType(oSetHashMap)=="O")
        oSetHashMap:=oSetHashMap:FreeObj()
    endif

    DEFAULT cXML:=""

return(cXML)

method ToHTML(lXML,cAttrSuffix) class JSONArray

    local cHTML            as character

    paramtype lXML as logical optional
    DEFAULT cAttrSuffix:="@"
    paramtype cAttrSuffix as character optional

    cHTML:="<!DOCTYPE html>"
    cHTML+="<html>"
    cHTML+="    <head>"
    if (self:lUTF8)
        cHTML+="        <meta http-equiv='content-type' content='text/html; charset=utf-8'/>"
    endif
    cHTML+="        <title></title>"
    cHTML+="    </head>"
    cHTML+="    <body>"
    cHTML+="        <pre>"
    cHTML+="            <code>"
    DEFAULT lXML:=.F.
    if (lXML)
        cHTML+=self:ToXML(/*cXMLRoot*/,cAttrSuffix,/*lArrayToList*/)
    else
        cHTML+=self:ToJSON()
    endif
    cHTML+="            </code>"
    cHTML+="        </pre>"
    cHTML+="    </body>"
    cHTML+="</html>"

    if (self:lPrettify)
        cHTML:=cTools():StrPrettify(cHTML,2,self:nPrettify)
    endif

return(cHTML)

method ToXHTML(cAttrSuffix) class JSONArray
    local cHTML as character
    DEFAULT cAttrSuffix:="@"
    paramtype cAttrSuffix as character optional
    cHTML:=self:ToHTML(.T.,self:lGetObjSuperClass,cAttrSuffix)
return(cHTML)

/*
static function: EscpJSONStr(cJSONStr)
Escapes string to a JSON string format
ToJSON() Automatically escapes strings,there is no much use of this function unless
you want to write the JSON strings yourself.

Example:
----
cProdName:='Cool" and \ cool"'

cJSON:='{"Product": {"Name": "'+EscpJSONStr(cProdName) +'"}}'

alert(JSONPrettify(cJSON)) // -> {"Product": {"Name": "Cool\" and \\ cool\""}}
----

@param cJSONStr - The String you want to escape
@return cJSONStr - Escaped JSON string
*/

method EscpJSONStr(cJSONStr) class JSONArray
    local cJSON as character
    paramtype cJSONStr as character
    cJSON:=EscpJSONStr(cJSONStr,@self:lUTF8,@self:lNoAccent,@self:lTrimSpace)
return(cJSON)

static function EscpJSONStr(cJSONStr as character,lUTF8 as logical,lNoAccent as logical,lTrimSpace as logical) as character
    local cEscpJSON as character
    cEscpJSON:=cJSONStr
    cEscpJSON:=strTran(cEscpJSON,'\','\\') // we must escape \ first,so it won't bug the rest
    cEscpJSON:=strTran(cEscpJSON,'"','\"')
    cEscpJSON:=strTran(cEscpJSON,CHR_FF,'\f')
    cEscpJSON:=strTran(cEscpJSON,CHR_LF,'\n')
    cEscpJSON:=strTran(cEscpJSON,CHR_CR,'\r')
    cEscpJSON:=strTran(cEscpJSON,CHR_HT,'\t')
    if (lUTF8.or.lNoAccent.or.lTrimSpace)
        cEscpJSON:=cTools():UTF8(cEscpJSON,@lUTF8,@lNoAccent,@lTrimSpace)
    endif

return(cEscpJSON)

/*
static function: JSONPrettify(cJSONstr [,nPrettify])
Prettify a JSON string. It will indent and make it more readable

Example:
-----
cJSON:='{"Products": [{"Name": "Water","Cost": 1.30},{"Name": "Bread","Cost": 0.40}]}'

alert(JSONPrettify(cJSON,4))

Result:

{
    "Products": [
        {
            "Name": "Water",
            "Cost": 1.30
        },
        {
            "Name": "Bread",
            "Cost": 0.40
        }
    ]
}
----

@param cJSONstr - The JSON string to prettify
@param nPrettify (opitional) - number of spaces for each indentation,-1 for tabs (\t) (DEFAULT: -1)
@return string - Prettified JSON string
*/
method JSONPrettify(cJSONstr,nPrettify) class JSONArray
    local cJSON as character
    paramtype cJSONstr  as character
    DEFAULT nPrettify:=self:nPrettify
    paramtype nPrettify as numeric optional
    cJSON:=JSONPrettify(cJSONstr,nPrettify)
return(cJSON)

static function JSONPrettify(cJSONstr,nPrettify) as character

    local cTab      as character
    local cLetter   as character
    local cBefore   as character
    local cJSONNew  as character

    local lInString as logical

    local nLetter   as numeric
    local nLetters  as numeric
    local nIdentLev as numeric

    DEFAULT nPrettify:=-1

    if (nPrettify>0)
        cTab:=replicate(" ",nPrettify)
    else
        cTab:=CHR_HT
    endif

    cLetter:=""
    cJSONNew:=""
    lInString:=.F.
    nIdentLev:=0

    nLetters:=Len(cJSONstr)
    for nLetter:=1 to nLetters
        cBefore:=cLetter
        cLetter:=subStr(cJSONstr,nLetter,1)
        if ((cLetter=="{").or.(cLetter=="["))
            if (!lInString)
                nIdentLev++
                cJSONNew+=(cLetter+CHR_CRLF+replicate(cTab,nIdentLev))
            else
                cJSONNew+=cLetter
            endif
        elseif ((cLetter=="}").or.(cLetter=="]"))
            if (!lInString)
                nIdentLev--
                cJSONNew+=(CHR_CRLF+replicate(cTab,nIdentLev)+cLetter)
            else
                cJSONNew+=cLetter
            endif
        elseif (cLetter==",")
            if (!lInString)
                cJSONNew+=(cLetter+CHR_CRLF+replicate(cTab,nIdentLev))
            else
                cJSONNew+=cLetter
            endif
        elseif (cLetter==":")
            if (!lInString)
                cJSONNew+=": "
            else
                cJSONNew+=cLetter
            endif
        elseif ((cLetter==" ").or.(cLetter==CHR_LF).or.(cLetter==CHR_HT))
            if (lInString)
                cJSONNew+=cLetter
            endif
        elseif (cLetter=='"')
            if ((!(cBefore=="\")).or.(!IsComment(cJSONstr,nLetter,nLetters)))
                lInString:=(!lInString)
            endif
            cJSONNew+=cLetter
        else
            cJSONNew+=cLetter
        endif
    next nLetter

return(cJSONNew)

/*
static function: JSONMinify(cJSONstr)
Remove spaces,breaklines,and comments

Comments are not allowed in the JSON specification,but we can remove them with this function.

Allowed comments:

*/
    // Single line comment

 /*  Multiple Lines
     Multiple Lines
     Multiple Lines*/
/*
Example:
-----
cJSON:='{'+CHR_CRLF
cJSON+='  // this is a comment'+CHR_CRLF
cJSON+='  "Products": [35,50]'+CHR_CRLF
cJSON+='}'

cJSON:=JSONMinify(cJSON) // -> returns '{"Products":[35,50]}'
-----

function ported from Chris Dary's JSONLint:
http://JSONlint.com/c/js/jsl.format.js
https://github.com/arc90/JSONlintdotcom/blob/master/c/js/jsl.format.js

A copy of his license should be at the top of this file.

@param cJSONstr - The JSON string to Minify
@return string - Minified JSON string
*/

method JSONMinify(cJSONstr) class JSONArray
    local cJSON as character
    paramtype cJSONstr as character
    cJSON:=JSONMinify(cJSONstr)
return(cJSON)

static function JSONMinify(cJSONstr as character) as character

    local cLetter           as character
    local cBefore           as character
    local cJSONNew          as character

    local lInString         as logical
    local lInLineCommt      as logical
    local lMultLineCommt    as logical

    local nLetter           as numeric
    local nLetters          as numeric

    cLetter:=""
    cJSONNew:=""
    lInString:=.F.
    lInLineCommt:=.F.
    lMultLineCommt:=.F.

    nLetters:=Len(cJSONstr)
    for nLetter:=1 to nLetters
        cBefore:=cLetter
        cLetter:=subStr(cJSONstr,nLetter,1)
        // strip comments
        if (lInLineCommt)
            if (cLetter==CHR_LF)// \n
                lInLineCommt:=.F.
            endif
        elseif (lMultLineCommt)
            if ((cBefore=="*").and.(cLetter=="/"))
                lMultLineCommt:=.F.
            endif
        elseif ((!lInString).and.(cLetter=="/").and.(subStr(cJSONstr,nLetter+1,1)=="/"))
            lInLineCommt:=.T.
        elseif ((!lInString).and.(cLetter=="/").and.(subStr(cJSONstr,nLetter+1,1)=="*"))
            lMultLineCommt:=.T.
            // real JSON
        elseif ((cLetter=="{").or.(cLetter=="["))
            cJSONNew+=cLetter
        elseif ((cLetter=="}").or.(cLetter=="]"))
            cJSONNew+=cLetter
        elseif (cLetter==",")
            cJSONNew+=cLetter
        elseif (cLetter==":")
            cJSONNew+=cLetter
        elseif ((cLetter==" ").or.(cLetter==CHR_LF).or.(cLetter==CHR_HT).or.(cLetter==CHR_CR))
            if (lInString)
                cJSONNew+=cLetter
            endif
        elseif (cLetter=='"')
            if ((!(cBefore=="\")).or.(!IsComment(cJSONstr,nLetter,nLetters)))
                lInString:=(!lInString)
            endif
            cJSONNew+=cLetter
        else
            cJSONNew+=cLetter
        endif
    next nLetter

return(cJSONNew)

static function IsComment(cJSONstr as character,nLetter as numeric,nLetters as numeric) as logical
    local cLetter       as character
    local cBefore       as character
    local lIsComment    as logical
    lIsComment:=.T.
    for nLetter:=(nLetter+1) to nLetters
        cBefore:=subStr(cJSONstr,nLetter,1)
        if (cBefore$',}{][')
            for nLetter:=(nLetter+1) to nLetters
                cLetter:=subStr(cJSONstr,nLetter,1)
                if (cLetter$'",}{][')
                    if (cBefore$',}{][')
                        lIsComment:=.F.
                    endif
                    exit
                endif
            next nLetter
            if (!lIsComment)
                exit
            endif
        endif
    next nLetter
return(lIsComment)

method ReadINIFile(cIniFile,cIgnoreToken) class JSONArray

    local cJSON     as character
    local cEncode   as character

    local oTFINI    as object

    paramtype cIniFile as character
    paramtype cIgnoreToken as character optional

    oTFINI:=TFINI():New(cIniFile,cIgnoreToken)
    cEncode:=if(self:lUTF8,"UTF-8","")
    cJSON:=oTFINI:ToJSON(cEncode,self:lPrettify,self:nPrettify)

    self:FromJSON(cJSON)

return(cJSON)

method ReadXMLFile(cFileName,cAttrSuffix,cURL,cEncoding,nOptions,lNameSpaces) class JSONArray
    local cJSON as character
    paramtype cFileName as character
    DEFAULT cAttrSuffix:="@"
    paramtype cAttrSuffix as character optional
    paramtype cURL as character optional
    paramtype cEncoding as character optional
    paramtype nOptions as numeric optional
    DEFAULT lNameSpaces:=.T.
    paramtype lNameSpaces as logical optional
    cJSON:=self:FromXML(cFileName,cAttrSuffix,cURL,cEncoding,nOptions,lNameSpaces)
return(cJSON)

/*
static function: ReadJSONFile(cFileName [,lStripComments])
Reads JSON from a JSON file.

Example:
-----
aaConf:=ReadJSONFile("D:\TOTVS\Config.JSON")
alert(aaConf[#'Product'][35][#'name'])
-----

@param cFileName - Filename
@param lStripComments (Optional) - .T. removes comments,.F. doesn't. (DEFAULT .T.)
@return AnyValue - returns the value of the JSON file
*/

method ReadJSONFile(cFileName,lStripComments) class JSONArray
    paramtype cFileName as character
    DEFAULT lStripComments:=.F.
    paramtype lStripComments as logical optional
    ReadJSONFile(@self,cFileName,lStripComments)
return(self)

static function ReadJSONFile(oJSONArray as object,cFileName as character,lStripComments) as object

    local cJSON as character

    begin sequence

        if (!File(cFileName))
            oJSONArray:lHasError:=.T.
            oJSONArray[#"error"]:="File ["+cFileName+"] does not exist."
            oJSONArray:SetErrorMsg(oJSONArray[#"error"])
            break
        endif

        cJSON:=cTools():ReadMemo(cFileName)

        DEFAULT lStripComments:=.F.
        if (lStripComments)
            cJSON:=JSONMinify(cJSON)
        endif

        oJSONArray:FromJSON(cJSON)

    end sequence

return(oJSONArray)

/// End of User functions

////////////////////////////////////////////////////////////////////////////////////////////////////////
// Bellow there are only internal functions which are necessary for the FromJSON function

/// Begin of Internal functions

/*
Internal function: GetJSONVal(cJSONstr)
Converts from a JSON string into any value it holds

@param cJSONstr - The JSON string you want to convert from
@return Array(
          uVal,- Value of the converted JSON string,or nil in case of a bad formatted JSON string.
          nPos  - Position of the last processed character. returns -1 in case of a bad formatted JSON string.
   )
*/

static function GetJSONVal(cJSONstr as character) as array

    local aRet      as array
    local aTmp      as array

    local cLetter   as character

    local nJSONstr  as numeric
    local nLetter   as numeric

    begin sequence

        nJSONstr:=Len(cJSONstr)
        for nLetter:=1 to nJSONstr
            cLetter:=subStr(cJSONstr,nLetter,1)
            if (cLetter=='"')
                aTmp:=JSONStr(subStr(cJSONstr,nLetter))
                break
            elseif (AT(cLetter,"0123456789.-")>0)
                aTmp:=JSONNum(subStr(cJSONstr,nLetter))
                break
            elseif (cLetter=="[")
                aTmp:=JSONArr(subStr(cJSONstr,nLetter))
                break
            elseif (cLetter=="{")
                aTmp:=JSONObj(subStr(cJSONstr,nLetter))
                break
            elseif (AT(cLetter,"TtFfNn")>0)//True,False or Null
                aTmp:=JSONTFN(subStr(cJSONstr,nLetter))
                break
            endif
        next nLetter

    end sequence

    if (len(aTmp)>0)
        if (aTmp[2]<0)
            aRet:={nil,-1} // Error Code
        else
            aRet:={aTmp[1],nLetter+aTmp[2]-1}
        endif
    endif

    DEFAULT aRet:={nil,-1}

return(aRet)

/*
Internal function: JSONArr(cJSONstr)
Converts from a JSON string containing only an Array into an Array

@param cJSONstr - The JSON string you want to convert from
@return Array(
          aVal,- Value of the JSON array,or nil in case of a bad formatted JSON string.
          nPos  - Position of the last processed character. returns -1 in case of a bad formatted JSON string.
   )
*/

static function JSONArr(cJSONstr as character) as array

    local aRet          as array
    local aTmp          as array
    local aJSONArr      as array

    local cLetter       as character

    local lNeedComma    as logical

    local nLetter       as numeric
    local nJSONstr      as numeric

    begin sequence

        aRet:=Array(0)
        lNeedComma:=.F.

        nJSONstr:=Len(cJSONstr)
        for nLetter:=2 to nJSONstr
            cLetter:=subStr(cJSONstr,nLetter,1)
            if ((!lNeedComma).and.(AT(cLetter,'"{[0123456789.-')>0))
                aTmp:=GetJSONVal(subStr(cJSONstr,nLetter))
                if (aTmp[2]<0)
                    aJSONArr:={nil,-1} // Error Code
                    break
                endif
                aAdd(aRet,aTmp[1])
                nLetter:=(nLetter+aTmp[2]-1) // -1 move to last character because the loop will add +1.
                lNeedComma:=.T.
            elseif ((lNeedComma).and.(cLetter==','))
                lNeedComma:=.F.
            elseif (cLetter==']')
                aJSONArr:={aRet,nLetter}
                break
            endif

        next nLetter

    end sequence

    DEFAULT aJSONArr:={nil,-1}

return(aJSONArr)

/*
Internal function: JSONObj(cJSONstr)
Converts from a JSON string containing only an Object into an Associative Array (jsonhash Object)

@param cJSONstr - The JSON string you want to convert from
@return Array(
          aaVal,- Associative Array (jsonhash Object) of the JSON object,or nil in case of a bad formatted JSON string.
          nPos  - Position of the last processed character. returns -1 in case of a bad formatted JSON string.
   )
*/

static function JSONObj(cJSONstr as character) as array

    local aRet          as array
    local aTmp          as array

    local cLetter       as character
    local cTmpStr       as character

    local nStep         as numeric
    local nLetter       as numeric
    local nJSONstr      as numeric

    local oJSONArray    as object

    oJSONArray:=Array(#)

    begin sequence

        cTmpStr:=""

        nStep:=1

        nJSONstr:=Len(cJSONstr)
        for nLetter:=2 to nJSONstr
            cLetter:=subStr(cJSONstr,nLetter,1)
            if ((nStep==1).and.(cLetter=='"'))
                aTmp:=JSONStr(subStr(cJSONstr,nLetter))
                if (aTmp[2]<0)
                    aRet:={nil,-1} // Error Code
                    break
                endif
                nLetter:=(nLetter+aTmp[2]-1)
                cTmpStr:=aTmp[1]
                nStep:=2
            elseif ((nStep==2).and.(cLetter==':'))
                nStep:=3
            elseif ((nStep==3).and.(AT(cLetter,'"{[0123456789.-TtFfNn')>0))
                aTmp:=GetJSONVal(subStr(cJSONstr,nLetter))
                if (aTmp[2]<0)
                    aRet:={nil,-1} // Error Code
                    break
                endif
                nLetter:=(nLetter+aTmp[2]-1)
                nStep:=4
            elseif ((nStep==4).and.(cLetter==','))
                oJSONArray[#cTmpStr]:=aTmp[1]
                nStep:=1
            elseif ((nStep==4).and.(cLetter=='}'))
                oJSONArray[#cTmpStr]:=aTmp[1]
                aRet:={oJSONArray,nLetter}
                break
            endif

        next nLetter

    end sequence

    DEFAULT aRet:={nil,-1}

return(aRet)

/*
Internal function: JSONStr(cJSONstr)
Converts from a JSON string containing only a String into a String

@param cJSONstr - The JSON string you want to convert from
@return Array(
          cVal,- Value of the JSON string,or nil in case of a bad formatted JSON string.
          nPos  - Position of the last processed character. returns -1 in case of a bad formatted JSON string.
   )
*/

static function JSONStr(cJSONstr as character) as array

    local aRet      as array

    local cLetter   as character
    local cTmpStr   as character

    local nUnic     as numeric
    local nLetter   as numeric
    local nJSONstr  as numeric

    begin sequence

        cTmpStr:=""

        nJSONstr:=Len(cJSONstr)

        for nLetter:=2 to nJSONstr
            cLetter:=subStr(cJSONstr,nLetter,1)
            if (cLetter=="\")
                nLetter++
                cLetter:=subStr(cJSONstr,nLetter,1)
                if (cLetter=='b')
                    cTmpStr+=CHR_BS
                elseif (cLetter=='f')
                    cTmpStr+=CHR_FF
                elseif (cLetter=='n')
                    cTmpStr+=CHR_LF
                elseif (cLetter=='r')
                    cTmpStr+=CHR_CR
                elseif (cLetter=='t')
                    cTmpStr+=CHR_HT
                elseif (cLetter=='u')
                    nUnic:=CTON(UPPER(subStr(cJSONstr,nLetter+1,4)),16)
                    if (nUnic<=255)
                        cTmpStr+=chr(nUnic)
                    else
                        cTmpStr+='?'
                    endif
                    nLetter+=4
                else
                    cTmpStr+=cLetter //it will add the char if it doesn't have a special function
                endif
            elseif (cLetter=='"')
                aRet:={cTmpStr,nLetter}
                break
            else
                cTmpStr+=cLetter
            endif
        next nLetter

    end sequence

    DEFAULT aRet:={nil,-1}

return(aRet)

/*
Internal function: JSONNum(cJSONstr)
Converts from a JSON string containing only a Number into a Number
It accepts the (Scientific) E Notation

@param cJSONstr - The JSON string you want to convert from
@return Array(
          nVal,- Value of the JSON number,or nil in case of a bad formatted JSON string.
          nPos  - Position of the last processed character. returns -1 in case of a bad formatted JSON string.
   )
*/

static function JSONNum(cJSONstr) as array

    local aRet      as array

    local cLetter   as character
    local cTmpStr   as character

    local lNegExp   as logical

    local nNum      as numeric
    local nLetter   as numeric
    local nJSONstr  as numeric

    lNegExp:=.F.

    begin sequence

        cTmpStr:=""

        nJSONstr:=Len(cJSONstr)

        for nLetter:=1 to nJSONstr
            cLetter:=subStr(cJSONstr,nLetter,1)
            if (AT(cLetter,'0123456789.-')>0)
                cTmpStr+=cLetter
            elseif (len(cLetter)>0).and.(UPPER(cLetter)=='E')
                nNum:=val(cTmpStr)
                cTmpStr:=""
                nLetter++
                cLetter:=subStr(cJSONstr,nLetter,1)
                if (cLetter=='-')
                    lNegExp:=.T.
                    nLetter++
                elseif (cLetter=='+')
                    nLetter++
                endif
                cLetter:=subStr(cJSONstr,nLetter,1)
                while (AT(cLetter,'0123456789')>0)
                    cTmpStr+=cLetter
                    nLetter++
                    cLetter:=subStr(cJSONstr,nLetter,1)
                end while
                if (lNegExp)
                    if (val(cTmpStr)!=0)
                        nNum*=(val('0.'+replicate('0',val(cTmpStr)-1)+'1'))
                    endif
                else
                    nNum*=(val('1'+replicate('0',val(cTmpStr))))
                endif
                aRet:={nNum,nLetter-1}
                break
            elseif (len(cLetter)>0)
                aRet:={val(cTmpStr),nLetter-1}
                break
            endif
        next nLetter

    end sequence

    DEFAULT aRet:={nil,-1}

return(aRet)

/*
Internal function: JSONTFN(cJSONstr)
Converts from a JSON string containing only a logical True,False or Null

@param cJSONstr - The JSON string you want to convert from
@return Array(
          lVal,- Value of the JSON logical value,or nil in case of Null or a bad formatted JSON string.
          nPos  - Position of the last processed character. returns -1 in case of a bad formatted JSON string.
   )
*/

static function JSONTFN(cJSONstr as character) as array

    local aRet      as array

    local cTmpStr   as character

    begin sequence

        cTmpStr:=lower(left(cJSONstr,5))

        if (cTmpStr=="false")
            aRet:={.F.,5}
            break
        endif

        cTmpStr:=left(cTmpStr,4)

        if (cTmpStr=="true")
            aRet:={.T.,4}
            break
        endif

        if (cTmpStr=="null")
            aRet:={nil,4}
            break
        endif

    end sequence

    DEFAULT aRet:={nil,-1}

return(aRet)
